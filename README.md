# Intelligent-Robotics

# Assignment 1

// Assignment_1

The code in the file is designed for a robot navigation task using ROS and Actionlib, specifically for controlling the TIAGO robot to move to a specified goal position. The program starts by including necessary header files such as for ROS functionality, for client-side action communication and a custom action header. It also includes headers for handling messages related to the robot's movement and pose.
The ActionClient type is defined to simplify interaction with the custom action server, which is responsible for controlling the robot's final position.
The feedbackCallback function is used to process and print real-time feedback from the robot, providing updates on its navigation progress.
In the main function, ROS is initialized, and the number of input arguments is checked to ensure the user provides the correct number of parameters (X, Y and theta) for the goal pose. An ActionClient object is created, which connects to the action server responsible for handling navigation tasks. The program waits for the server to be available and ready, then constructs a goal message using the input parameters for the desired X, Y, and theta coordinates. The robot is briefly given time to prepare before starting the movement towards the goal. The goal is then sent to the action server, and the feedbackCallback function is registered to receive updates on the robot's progress. The client waits for the action to be completed, with a timeout set to 60 seconds. If the robot reaches the goal within the time limit, the final state of the action is logged; otherwise, a warning is issued indicating that the action did not finish in time. The program ends after this, and the robot's navigation process is considered complete.

// Robot

The file defines a component responsible for handling requests from the assignment_1 client, guiding the TIAGO robot to navigate safely towards a target pose while avoiding obstacles. The code begins as before by including necessary libraries for ROS, Actionlib and message types, custom action messages and a new part; sensor data for obstacle detection using LaserScan. The MoveBaseClient and actionServer types are defined to simplify communication with the move_base action client and the final_pose action server, respectively.
The final_poseActionAction class is defined to encapsulate the core logic. It includes a NodeHandle, an action server for managing goals, and feedback and result message structures. The class constructor initializes the action server with a callback function executeCB and starts the server. The navigateToGoal method handles the navigation process, sending the robot to the target pose using MoveBaseClient. The method waits for the action server to become available, constructs a goal message with the provided X, Y and theta values, and sends it to the move_base action client. During navigation, feedback is published to update the client about the robot's progress, including its status ("STARTED NAVIGATING" or "FINISHED NAVIGATING"). Upon completion, if the robot successfully reaches the goal, a success message is logged; otherwise, an error is reported.
The executeCB method serves as the callback when a new goal is received. It checks for preemption requests, ensuring that the goal can be safely pursued, and calls the navigateToGoal method to guide the robot. If the goal is achieved, the result is marked as successful, and the action server is notified.
The feedbackCallback processes real-time navigation feedback, publishing updates to the action server about the robot's current position (X, Y) and status ("IS NAVIGATING").
Finally, in the main function, the ROS node is initialized, and an instance of the final_poseActionAction class is created to manage robot navigation. The node runs using ros::spin(), waiting for incoming action requests and handling them accordingly. The program completes when the ROS node is shut down.

// Scanner

The file implements a ROS node designed to detect obstacles in the environment using laser scan data from a robot's sensor. The program processes the incoming LaserScan messages to identify potential obstacles and publishes their positions as messages of a custom type, assignment_1::obstacle_msg.
The code begins with the inclusion of necessary headers for ROS functionalities, LaserScan for handling laser scan messages, and obstacle_msg for the custom message type. It also
includes standard libraries like cmath and vector for mathematical operations and data structures, respectively.
A class named CartesianPoint is defined to represent points in Cartesian coordinates, encapsulating X and Y values with corresponding getter methods. Global vectors obstacle_x_centers and obstacle_y_centers are declared to store the X and Y coordinates of detected obstacles.
The function isWithinCircle checks if all points in a given set are close to a specified circle, based on a defined radius and tolerance for deviation. This function is for validating whether detected points form a valid obstacle.
The detectCircle function is responsible for identifying circles formed by blocks of points. It requires at least three points to define a circle and calculates midpoints and slopes to find the circle's center and radius. It checks for concavity to ensure only valid convex shapes are processed. If the identified circle's radius falls within predefined limits, the center of the circle is recorded as an obstacle, and a message is logged.
The laserScanCallback function is called whenever a new LaserScan message is received. It extracts the number of points from the scan data and populates a vector of CartesianPoint objects representing the points in the robot's environment. The points are divided into blocks based on gaps in the data, which helps in processing them more efficiently. For each block with sufficient points, the detectCircle function is called to identify potential obstacles.
In the main function, the ROS node is initialized, and a subscriber is created to listen for LaserScan messages on the /scan_raw topic. A publisher is also established to send obstacle data using the assignment_1::obstacle_msg message type. The node runs in a loop, periodically publishing the detected obstacle positions while continuously processing incoming messages using ros::spinOnce().
This code integrates laser scan data processing to detect obstacles in the robot's environment, enabling further navigation and obstacle avoidance strategies for the TIAGO robot.
